<h1>Academic Intelligence</h1>
<h2>Web of Science Database Query Application</h2>

<h3>Preliminary</h3>

<p>Web of Science (WoS) is an online subscription-based scientific citation indexing service maintained by Thomson Reuters that provides a comprehensive citation search.</p>
<p>In other words, it’s a service that you can pay to use which provides databases of information on academic journals and publications, particularly regarding the number of citations for certain papers/authors.</p>
<p>This project seeks to replicate the functionality of the website (http://apps.webofknowledge.com) in a way that we can better manipulate the returned dataset to suit our own needs.  For example; extracting the pertinent data, refining it and displaying it in a suitable way.</p>
<p>WoS provides a Web Service API that allows a subscriber to manually interrogate the databases in the form of XML data exchanges performed using SOAP exchanges.<p>
<p>This was initially done using SoapUI, which is a web service testing application.  These exchanges would have to be run through SoapUI and returned the data into an Excel spreadsheet for further analysis.</p>
<p>Taking the project further, we decided that it would be best to design and develop our own application instead of relying on SoapUI.  This would give us greater control over the environment and format of data returned.  Putting the application on the web also means that users can access it via their browser without having to install software to their computer.</p>
<p>The current web application has a front end web page with a form that allows a user to enter keywords and search parameters.  The provided details are then processed with PHP which sends the SOAP Request to WoS and receives the SOAP Response.  This data is then refined and sent in a JSON file to another web page which processes and displays the data using JQuery and Data Driven Documents (D3).</p>

<h3>Site Structure</h3>

<h4>index.html</h4>

<p>This is the front end page for the site where a user can enter search parameters to request data from WoS.  The most important section here is the web form as this is how the data is passed to the PHP processing file (wos.php).</p>
<p>The form element is given a method attribute post and an action attribute wos.php.  This is telling the page that everything submitted within the scope of the form needs to be sent as an HTTP post transaction to the file wos.php.</p>
<p>The values set for the dropdown menus are taken from the WoS documentation and the hidden fields are displayed/hidden using a function from script.js.</p>

<h4>wos.php</h4>
<p>This is where the data is retrieved from WoS and processing is done.  When running from localhost, the password to connect to the MySQL database is stored in config.php, included in this file at the start.  This is just a small security measure when running the site locally.  When running the site from the server, the credentials for database login are retrieved using the global $_SERVER variable, created by the web server.</p>
<p>The section after this deals with establishing a SOAP client and setting the WSDL for authentication for using the WoS Web Service.  The SID returned from the successful authentication is stored as a Cookie for use throughout the data retrieval.</p>
<p>The SOAP Request is then sent using the input from the form in index.html.  There is a check to see if any data has been passed into the ‘hidden’ search fields and then an array is created storing the data needed for the WoS SOAP Request.  The correct data and format for this is found in the WoS documentation.  Two arrays are created to later store required data, $recordArray will store all the data returned from WoS, and $citedArray will stored the top ten cited authors.</p>
<p>There is a maximum count of 100 records per request so the for loop for the query starts at 1 and increments by 100 each time.  This for loop lasts up until $recordArray is fully populated by all records.</p>
<p>$search_response then performs the request and stores the returned SOAP Response data as an object.  The length of the property recordsFound of this object tells us how many records have been returned, which will tell us when to end the upcoming loop.</p>
<p>The records property stores the data we are interested in and in order to be able to navigate this data, it is turned into a SimpleXMLElement object.  Variables for the different elements we are interested in are created outside the foreach loop to store the data for each iteration.</p>
<p>Each record is stored in a REC tag within records, the foreach loop cycles through each of these tags and stores the relevant data into the global variable (it also echoes the data in a table to monitor what’s going on).  As sometimes certain values don’t exist, some of the elements must be tested to see if they are present before saving them, otherwise setting them to ‘no record’.</p>
<p>After one iteration a new array is created called $arecord which stores all the data from a single record in a key=>value format.  This is then pushed to $recordArray where it is stored as the next data record.
When elements are inserted into a MySQL database, the apostrophe ( ‘ ) character causes problems in that it makes MySQL think that it has reached the end of a value.  Therefore the next for loop iterates $recordArray and replaces all instances where there is an apostrophe.</p>
<p>There can be many authors associated with a publication so we have only taken the first three listed.  As we want to refine our data to the top ten from $recordArray, we iterate the first ten records and copy each author into $citedArray (10 records x 3 authors = 30 records).</p>
<p>We are not interested in any ‘no record’ values so these are removed next by checking for this value in $citedArray and using unset to remove it.  Then we need to remove duplicates using array_unique so that we are left with a unique set of author names, saved as $singleAuthors.  NOTE: There will still be duplicates here where some author names are in uppercase and lowercase, this will be dealt with later.</p>
<p>Next we connect to the MySQL database using either the local file, config.php, or the server global variables.  If the database wos doesn’t exist then it is created here.  There are two tests following this to try and get results from the tables searchresponse and topcited, if these come back empty then they are created to store the values from the dataset.</p>
<p>To avoid consecutive data searches being saved in the same table, TRUNCATE TABLE empties the tables (if they already existed and were populated).  We then populate the searchresponse table with the data from $recordArray.
The $result variable is initialised as an integer in order to store the summed citations value when iterating the foreach loop.  The loops are used to compare the authors in $singleAuthors with the various author values in $recordArray, if there is a match then the citations value at that point is added to $result.  This author and summed citation value are then inserted into topcited and $result is set back to zero for the next author iteration.</p>
<p>The data from topcited is SELECTed and inserted into the $rows array so that it now holds author names with their associated summed citations values.  All the author values in this array are now capitalised using strtoupper so that uppercase and lowercase duplicates are now the same case.</p>
<p>$tempArray is created from $rows and is identical; this is used so that we can iterate them both to compare values to check for duplicates.  Duplicates are removed using unset and the indices are reset using array_values (removing an element from an array with unset also removes the index at that point).</p>
<p>Calling usort on the array ensures that it is sorted correctly by highest citation value to lowest.  We only want the top ten authors, so array_slice returns only the number specified in the parameter for this function.
This data is now ready to be used in data.html and is encoded as a JSON for easier use with JavaScript.  Using file_put_contents will cause the data to be written to a file on the server that can be called by data.html, and json_encode ensures that it’s in the correct format.</p>
<p>Lastly, just for monitoring purposes the data is printed into another table, the MySQL connection is closed and the page is redirected to data.html.</p>

<h4>data.html</h4>

<p>Although this is an HTML file, the majority of code here is in JQuery and D3.  There are the standard headers and HTML elements for the page before the script is initiated.</p>
<p>First thing is to get the data file we created in wos.php, data.json and make it a parameter of the function for getJSON.  This data is assigned to the variable topCited and some console.logs are used to check that the data has been imported correctly.</p>
<p>The unusual thing about D3 is that you can select HTML elements that don’t exist yet.  We select the body of the document and then selectAll paragraph elements (although there aren’t any declared).  We associate our data with this and use the enter() function to create new placeholders in the DOM for our paragraph elements.  Finally these are appended to the body of the document.</p>
<p>These paragraph elements are currently empty so next we selectAll and call the text function with parameters d for the data and i for the index and insert this data onto each p.  On the page this is shown as the list of authors from 0-9 with the associated citations value.</p>
<p>That part was just a test, however, to make sure that the data is correct and that D3 is functioning correctly.  Now we will use this data to create our bar chart.</p>
<p>Firstly we create a margin object to stores some margins for the bar chart; by keeping these together in one place, it is easier to amend them than having to search for all the instances of them in the code.  The sizes of these are determined by the space needed for the axis labels.  A height and width is then established for the size of the svg element that will act as the canvas for the bar chart.</p>
<p>As the citations value will constitute the y-axis, the largest value (first element) can be used to set maxY which will determine the domain for the linear scale for the bars themselves.  There are a number of scales available in D3, a linear scale will be used here for the citations values (numeric) and an ordinal scale will be used for the author names.</p>
<p>In order to set the linearScale, we need to map the domain, which is the data, to the range, which is the height of the canvas for the chart.  D3 will then create a suitable scale accordingly.  We have already determined that the maximum value for our data is maxY so we can set the domain from 0 to this.  This will be mapped to a range from 0 to the height.</p>
<p>The variable svgContainer is created where we select the .chart div and append an svg element.  The size is given according to the previously set height, width and margin variables.  This is our canvas for the bar chart to occupy.
The variable barGroup takes svgContainer and appends an SVG Grouped Element (g).  This is used to group SVG elements together and so the bars of the chart will be represented by a g.  Similarly, later the x- and y-axis will also be represented by a g each.</p>
<p>Next we bind the data to SVG rectangle elements which will represent the bars of the chart.  In the same way as previously, the rect elements are created and then given some attributes, all saved as variable bar.
The bars are given the attribute fill to give them some colour, some functions are then set up so that the colour changes when the mouse pointer enters and exits the area of a bar.  Namely when you mouseover a bar it changes the fill to darkblue, and when you mouseout from a bar it changes the colour to #4aaeea, but with a gradual duration of 250ms.  This means that if you scroll your mouse pointer it creates a wave effect with the colour.  Unecessary but it looks nice!</p>
<p>The barWidth variable covers the width of one of the bars plus 3px padding between each bar.  Setting the attributes for the bars, we select the previously created bar and assign it to rectAttributes.  We then set the width of each bar to 75px and the height of each to the linearScale we previously created called upon the citations_sum value of the data for each record.</p>
<p>We then need to set the x and y coordinates for each bar.  The parameters passed into the function for the x attribute, d and i, represent the data and the indices of the data.  Therefore we know that the distance along the x-axis for each bar is its index multiplied by barWidth.  This allows for the width of one bar plus the 3px padding.  So 1st bar = 0*78, 2nd bar = 1*78, 3rd bar = 2*78, etc.  This ensures that the bars do not overlap and display correctly horizontally.</p>
<p>Coordinates in SVG elements are calculated from the top-left corner.  Therefore when calculating the y-coordinates for the bars, we need to take into account that any measurement starts at the top of the SVG canvas.  We want our bar chart to display from the bottom so the calculation for y takes the height of the SVG canvas and takes away the height of the bar, determined as previously by applying linearScale to each citations_sum value in the data.  This makes sure that every bar is aligned to the bottom of the graph.</p>
<p>Now we have our bars on our bar chart, it’s time to add some text and axis.  A new variable text is assigned to appending text elements to barGroup.  barLabels then takes text and applies some attributes.  Firstly the x coordinate is established in the same way as with the rect elements earlier, but this time adding 37.5 so that the text is aligned halfway between each bar.</p>
<p>The y coordinate is found as before for the height of the bars but subtracting 3 so that the text sits just above each bar to make it more legible.  The actual text to display is done by passing the data into a function and returning the value for each citations_sum.  Finally here some styling is done on the text.</p>
<p>Next we establish some scales for the axes before creating the axes themselves.  The x-axis uses an ordinal scale and maps the domain to the author names.  The space for each name is allocated using rangeRoundBands which specifies the boundaries, namely the width of a bar.</p>
<p>The y-scale is linear as it is relates to numerical values.  This is very similar to the scale created for the bars except that the range is reversed.  It needs to be this way as, if you remember, measurements are calculated from the top-left corner of the SVG canvas so to ensure that the 0 is at the bottom of the y-axis, we need to specify it last.</p>
